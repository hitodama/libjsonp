= libjsonp

== API

Provides a drop-in pointer extension to jansson. Also provides some extension functions to jansson to unify its object and array APIs.

For pointers themself and examples see: http://tools.ietf.org/html/rfc6901

=== Tilde pointer functions:

[source,c]
----
json_t *jsonp_create(json_t *json, const char *pointer, json_t *value);
json_t *jsonp_create_new(json_t *json, const char *pointer, json_t *value);
json_t *jsonp_get(json_t *json, const char *pointer);
int jsonp_set(json_t *json, const char *pointer, json_t *value);
int jsonp_set_new(json_t *json, const char *pointer, json_t *value);
int jsonp_delete(json_t *json, const char *pointer);
----

=== Tilde & URL encoding pointer functions:

[source,c]
----
json_t *jsonpp_create(json_t *json, const char *pointer, json_t *value);
json_t *jsonpp_create_new(json_t *json, const char *pointer, json_t *value);
json_t *jsonpp_get(json_t *json, const char *pointer);
int jsonpp_set(json_t *json, const char *pointer, json_t *value);
int jsonpp_set_new(json_t *json, const char *pointer, json_t *value);
int jsonpp_delete(json_t *json, const char *pointer);
----

=== Type switching

The "create" functions also support an extension which allows type setting of pointer parts. The extension is based on the $$~ escape character. By using ~ and the first letter of the type (such as ~a for array, ~s for string, etc.) the type of a pointer part such as /foo~a can be expressed$$. Without such an extesion, JSON pointers are a little ill-equiped to support easy creation scenarios. Additionally, the URL functions support a URL based type setting via the non-printable URL encoding parts %00 - %07 (see janssons type enum or jansson_extension.c for concrete values). If you would like to remove the extension, compile the code with JSONP_WITH_TYPESWITCH 0.

== Bin

Besides the shared library the lib can also be build as a neat little binary. See -h for more

== Example

The examples below shows multiple "create" scenarios. Additionally they show "get", "set" and "delete" scenarios. This examples are also viable examples for the library.

[source,bash]
----
echo "{}" | jsonp set -t real "foo" 2 | jsonp create "moo~r" 3 | jsonp create -pp "/1/%03abc" 42.2222  | jsonp create "/bar/baz" 3.141 | jsonp get "" && printf "\n"
{"moo": 3.0, "foo": 2.0, "1": {"abc": 42}, "bar": {"baz": 3.141}}

echo "{}" | jsonp create -pp "/foo~a/-/bar%04" "42" | jsonp create "/foo/-/abc" def | jsonp create "/foo/-" 123 && printf "\n"
{"foo": [{"bar": 42.0}, {"abc": "def"}, 123]}

echo "{\"foo\": [{\"bar\": 42.0}, {\"abc\": \"def\"}, 123]}" | jsonp get "/foo" && printf "\n"
[{"bar": 42.0}, {"abc": "def"}, 123]

echo "{\"foo\": [{\"bar\": 42.0}, {\"abc\": \"def\"}, 123]}" | jsonp get "/foo/2" && printf "\n"
123

echo "{\"foo\": [{\"bar\": 42.0}, 123]}" | jsonp delete "/foo/0" | jsonp create "/foo/-~f" | out/bin/jsonp get "foo" && printf "\n"
[123, false]
----

== Todo

* Need better tests (currently a simple dummy)
* Need better build system / Makefile (help welcome)
* Speed can be improved (mostly by more complex string handling)